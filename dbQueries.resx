<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="changeDB" xml:space="preserve">
    <value>use [&lt;DB&gt;];</value>
    <comment>changeDB</comment>
  </data>
  <data name="databaseList" xml:space="preserve">
    <value>select d.name
from sys.databases d
order by d.name;</value>
    <comment>databaseList</comment>
  </data>
  <data name="findReferencedObjs" xml:space="preserve">
    <value>--declare @ObjectName sysname = 'dbo.korm_Request_CheckBusinessLogic';

if object_id('tempdb..#weakObj') is null
	create table #weakObj (objName sysname not null);

IF EXISTS (
    select 1
    from #weakObj w
    where w.objName = @ObjectName
)
BEGIN
  SELECT '&lt;not avaible: weak object&gt;' refName;
END
ELSE
BEGIN
  SELECT DISTINCT
    ISNULL(re.referenced_schema_name, 'dbo')
    + '.'
    + re.referenced_entity_name
    + ISNULL('.' + re.referenced_minor_name, '') refName
  , re.referenced_database_name refDbName
  , o.[type]
  FROM sys.dm_sql_referenced_entities(@ObjectName, 'object') re
  LEFT JOIN sys.objects o
     ON o.[object_id] = re.referenced_id
  WHERE re.referenced_minor_id = 0;
END;</value>
    <comment>поиск содержащихся объектов</comment>
  </data>
  <data name="findReferencedTriggers" xml:space="preserve">
    <value>--declare @TableName sysname = 'dbo.Table1'

declare @objid int;

select @objid = object_id(@TableName);

select
 refName = schema_name(schema_id) + '.' + o.name,
 refDbName = NULL, /* current db */
 [type] = o.type 
 from sys.objects o
 where parent_object_id = @objid and type IN ('TR','TA')</value>
  </data>
  <data name="getDbName" xml:space="preserve">
    <value>select db_name();</value>
    <comment>Имя текущей БД</comment>
  </data>
  <data name="getObjectType" xml:space="preserve">
    <value>select ltrim(rtrim(o.type)) object_type
from sys.objects o
where o.object_id = object_id(@ObjectName)

UNION ALL

select ltrim(rtrim(obj.type)) object_type
from sys.table_types tt
INNER JOIN sys.objects AS obj ON obj.object_id = tt.type_table_object_id
where schema_name(tt.schema_id) + '.' + tt.name = @ObjectName</value>
    <comment>Получить тип объекта</comment>
  </data>
  <data name="objectList" xml:space="preserve">
    <value>--declare @SearchText sysname;

select SCHEMA_NAME(o.schema_id) + '.'+ OBJECT_NAME(o.object_id) FullName
, DB_NAME() DatabaseName
, o.type
, o.type_desc
, o.modify_date
from sys.objects o
where o.name like '%' + isnull(@SearchText,'') + '%'
  AND o.type not in ('S', 'IT', 'SQ')
  AND o.type IN (&lt;objTypes&gt;)
  and o.is_ms_shipped = 0

UNION ALL

select schema_name(tt.schema_id) + '.' + tt.name FullName
, DB_NAME() DatabaseName
, obj.type --'TT' [type]
, obj.type_desc --'TableType' [type_desc]
, obj.modify_date
from sys.table_types tt
LEFT JOIN sys.objects AS obj ON obj.object_id = tt.type_table_object_id
where tt.name like '%' + isnull(@SearchText, '') + '%'
  AND obj.type IN (&lt;objTypes&gt;)

order by FullName;</value>
    <comment>objectList</comment>
  </data>
  <data name="objectSearchBySource" xml:space="preserve">
    <value>--declare @SearchText varchar(max) = 'data';

with cte as
(
select
	SCHEMA_NAME(o.schema_id) schema_name,
	o.name object_name,
	o.type object_type,
	o.type_desc object_type_desc,
	o.modify_date,
	m.definition [definition],
	left(m.definition, 100) start_definition,
	PATINDEX('%' + @SearchText + '%', m.definition) found_definition_index
from sys.sql_modules m
	inner join sys.objects o on o.object_id = m.object_id
WHERE
	m.definition like '%' + @SearchText + '%'
	--AND o.type = 'P'
)
select cte.schema_name + '.' + cte.object_name [FullName],
	DB_NAME() DatabaseName,
	cte.object_type [type],
	cte.object_type_desc [type_desc],
	cte.modify_date
from cte
order by 1, 2</value>
  </data>
  <data name="prepareWeakObjects" xml:space="preserve">
    <value>-- поиск "плохих" объектов
-- (на которые нельзя найти ссылки)

set nocount on;

if OBJECT_ID('tempdb..#weakObj') is not null
  drop table #weakObj;
create table #weakObj (objId int primary key, objName varchar(100) not null);

declare @objId int, @objName sysname;
declare @res table (r int not null);

declare cr cursor local
for
  select o.object_id objId
  , OBJECT_SCHEMA_NAME(o.object_id, DB_ID()) + '.' + o.name objName
  from sys.all_objects o
  where o.type in ('u', 'f', 'fn', 'p');

open cr;

while 1=1
begin
  fetch cr into @objId, @objName;
  if @@FETCH_STATUS&lt;&gt;0
    break;

  begin try
  
  insert @res(r)
  select 1
  from sys.dm_sql_referenced_entities(@objName, 'object') re;
  
  end try
  begin catch
    print @objName + ' (' + cast(@objId as varchar(50)) + ')';
    print error_message();
    

    insert #weakObj (objId, objName)
    values (@objId, @objName);

  end catch
end;

close cr;
deallocate cr;</value>
    <comment>prepareWeakObjects</comment>
  </data>
  <data name="showSource" xml:space="preserve">
    <value>--declare @ObjectName sysname;
--set @ObjectName = '[dbo].[CustOrdersOrders]'
--set @ObjectName = 'dbo.Orders';

declare @otype char(1);
select top(1) @otype = o.type
from sys.objects o
where o.object_id = object_id(@ObjectName);

if @otype not in ('U') /* table */
begin
	SELECT sm.object_id
	, object_schema_name(sm.object_id) + '.' + OBJECT_NAME(sm.object_id) AS object_name
	, o.type
	, o.type_desc
	, sm.definition
	FROM sys.sql_modules AS sm
	JOIN sys.objects AS o ON sm.object_id = o.object_id
	where sm.object_id = object_id(@ObjectName)
	and o.type not in ('U') /* table */
end

if @otype = 'U' /* table */
begin
	with obj as
	(
		select
		object_schema_name(o.object_id) + '.' + OBJECT_NAME(o.object_id) AS object_name
		, o.object_id
		, o.type
		, o.type_desc
		from sys.objects o
		where o.object_id = object_id(@ObjectName)
	)
	, cols as
	(
		select
		c.name col_name
		, t.system_type_id
		, t.name system_type_name
		, t.is_table_type
		, t.is_user_defined
		, c.is_identity
		, c.is_nullable
		, c.is_computed
		, c.is_xml_document
		, c.xml_collection_id
		, c.max_length
		, c.precision
		, c.scale
		, c.collation_name
		, c.column_id
		from obj o
		inner join sys.columns c on c.object_id = o.object_id
		left join sys.types t on t.user_type_id = c.user_type_id
	)
	, sql_str as
	(
		select [definition] = 
		(
			select
				c.col_name + ' '
				+ c.system_type_name + ' '
				+ case c.is_nullable
					when 1 then 'NOT NULL'
					else 'NULL'
				end
				+ case c.is_identity
					when 1 then ' IDENTITY'
					else ''
				end
				+ char(10)
			from cols c
			order by c.column_id
			for xml path('')
		)
	)
	select 
	o.object_id
	, o.object_name
	, o.type
	, o.type_desc
	, definition =
	'Table: ' + o.object_name
	+ char(10) + 'Columns: '
	+ char(10) + s.definition
	from obj o
	cross join sql_str s;

end;</value>
    <comment>Отображение текста объекта</comment>
  </data>
  <data name="showTableSource" xml:space="preserve">
    <value>set nocount on
--declare @ObjectName sysname = 'dbo.Products'

/* входящие объекты */
declare @objects table (
	schemaName sysname not null,
	tableName sysname not null

	primary key (schemaName, tableName)
)

/* исходящие строки */
declare @output table (
	schemaName sysname not null,
	tableName sysname not null,
	rownum bigint not null,
	rowtype varchar(50) not null,
	indent int default(0), --отступ при форматировании запроса
	sqltext varchar(max) null,
	endType tinyint default(0) --тип строки. 0-обычная, 1-после строки GO, 2-после строки запятая

	primary key (schemaName, tableName, rownum)
)

if object_id('tempdb..#ansi_params') is not null
  drop table #ansi_params;

if object_id('tempdb..#columns') is not null
  drop table #columns;

IF OBJECT_ID('tempdb..#colDefaults') IS NOT NULL
  DROP TABLE #colDefaults;

if object_id('tempdb..#index_name') is not null
  drop table #index_name;

if object_id('tempdb..#index_columns') is not null
  drop table #index_columns;

if object_id('tempdb..#fk_name') is not null
  drop table #fk_name;

if object_id('tempdb..#fk_cols') is not null
  drop table #fk_cols;

if object_id('tempdb..#table_chk') is not null
  drop table #table_chk;

--0. подготовка списка объектов
insert @objects (schemaName, tableName)
select
	schema_name(t.schema_id) sName,
	t.name tName
from
	sys.tables t
where t.object_id = object_id(@ObjectName)
order by
	schema_name(t.schema_id), t.name


--1. определение параметров ANSI_NULLS, QUOTED_IDENTIFIER
SELECT
	SCHEMA_NAME(tbl.schema_id) AS sName,
	tbl.name AS tName,
	tbl.uses_ansi_nulls AS AnsiNullsStatus,
	CASE WHEN 'FG'=dsidx.type THEN dsidx.name ELSE N'' END AS [FileGroup],
	CAST(
	 case 
		when tbl.is_ms_shipped = 1 then 1
		when (
			select 
				major_id 
			from 
				sys.extended_properties 
			where 
				major_id = tbl.object_id and 
				minor_id = 0 and 
				class = 1 and 
				name = N'microsoft_database_tools_support') 
			is not null then 1
		else 0
	 end
	AS bit) AS IsSystemObject,
	CAST(OBJECTPROPERTY(tbl.object_id,N'IsQuotedIdentOn') AS bit) AS QuotedIdentifierStatus
into #ansi_params
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.indexes AS idx ON idx.object_id = tbl.object_id and idx.index_id &lt; 2
	LEFT JOIN sys.data_spaces AS dsidx ON dsidx.data_space_id = idx.data_space_id

insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	sName,
	tName,
	0,
	'ANSI-params',
	case
		when AnsiNullsStatus=1
		then 'SET ANSI_NULLS ON'
		else 'SET ANSI_NULLS OFF'
	end sqltext,
	1
from
	#ansi_params

insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	sName,
	tName,
	1,
	'ANSI-params',
	case
		when QuotedIdentifierStatus=1
		then 'SET QUOTED_IDENTIFIER ON'
		else 'SET QUOTED_IDENTIFIER OFF'
	end sqltext,
	1
from
	#ansi_params

--2. нужен ли SET ANSI_PADDING?

--3a. создание названия таблицы
insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	sName,
	tName,
	5,
	'tableHeader',
	'CREATE TABLE [' +sName +'].[' +tName +'](',
	0
from
	#ansi_params


insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	sName,
	tName,
	7000,
	'tableFooter',
	') ON [' +[FileGroup] +']',
	1
from
	#ansi_params


--3b. создание столбцов таблицы
SELECT
	SCHEMA_NAME(tbl.schema_id) AS [sName],
	tbl.name AS [tName],
	Row_Number() OVER (Partition by tbl.schema_id, tbl.name Order by clmns.column_id) AS [ID],
	clmns.name AS [colName],
	clmns.is_ansi_padded AS [AnsiPaddingStatus],
	clmns.is_computed AS [Computed],
	ISNULL(cc.definition,N'') AS [ComputedText],
	usrt.name AS [DataType],
	ISNULL(baset.name, N'') AS [SystemType],
	sclmns.name AS [DataTypeSchema],
	CAST(clmns.is_rowguidcol AS bit) AS [RowGuidCol],
	CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND clmns.max_length &lt;&gt; -1 THEN clmns.max_length/2 ELSE clmns.max_length END AS int) AS [Length],
	CAST(clmns.precision AS int) AS [NumericPrecision],
	clmns.is_identity AS [Identity],
	CAST(ISNULL(ic.seed_value,0) AS bigint) AS [IdentitySeed],
	CAST(ISNULL(ic.increment_value,0) AS bigint) AS [IdentityIncrement],
	ISNULL(clmns.collation_name, N'') AS [Collation],
	CAST(clmns.scale AS int) AS [NumericScale],
	clmns.is_nullable AS [Nullable],
	CAST(ISNULL(cc.is_persisted, 0) AS bit) AS [IsPersisted],
	tbl.object_id as objectid
INTO #columns
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.all_columns AS clmns ON clmns.object_id=tbl.object_id
	LEFT OUTER JOIN sys.computed_columns AS cc ON cc.object_id = clmns.object_id and cc.column_id = clmns.column_id
	LEFT OUTER JOIN sys.types AS usrt ON usrt.user_type_id = clmns.user_type_id
	LEFT OUTER JOIN sys.types AS baset ON baset.user_type_id = clmns.system_type_id and baset.user_type_id = baset.system_type_id
	LEFT OUTER JOIN sys.schemas AS sclmns ON sclmns.schema_id = usrt.schema_id
	LEFT OUTER JOIN sys.identity_columns AS ic ON ic.object_id = clmns.object_id and ic.column_id = clmns.column_id
ORDER by
	sName, tName, ID


-- 3c. Default значения
SELECT
	SCHEMA_NAME(tbl.schema_id) AS [sName],
	tbl.name AS [tName],
	clmns.name AS [colName],
	cstr.name AS [defaultName],
	CAST(cstr.is_system_named AS BIT) AS [IsSystemNamed],
	cstr.definition AS [Text]
INTO #colDefaults
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.all_columns AS clmns
		ON  clmns.object_id = tbl.object_id
	INNER JOIN sys.default_constraints AS cstr
		ON  cstr.object_id = clmns.default_object_id
ORDER BY
	sName, tName, colName

insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	c.sName,
	c.tName,
	10 +c.ID,--rowid,
	'columns',
	1,
	'[' +c.colName +'] [' +c.DataType +'] ' +
	case
		when lower(c.DataType)='char' OR lower(c.DataType)='nchar' OR lower(c.DataType)='binary'
		then '(' +cast(c.[Length] as varchar) +') '

		when lower(c.DataType)='varchar' OR lower(c.DataType)='nvarchar' OR lower(c.DataType)='varbinary'
		then '('+
			case c.[Length]
				when -1 then 'max'
				else cast(c.[Length] as varchar)
			end +
			') '

		when lower(c.DataType)='numeric' OR lower(c.DataType)='decimal'
		then '(' +cast(c.NumericPrecision as varchar) +',' +cast(c.NumericScale as varchar) +') '

		when lower(c.DataType)='float'
		then '(' +cast(c.NumericPrecision as varchar) +') '		

		else ''
	end +
	case
		when isnull(c.Collation, '')=''
		then ''
		else 'COLLATE ' +c.Collation +' '
	end +

--	[DescriptTableId] [tinyint] IDENTITY(1,1) NOT NULL,
	CASE
		WHEN c.[Identity] = 1
		THEN 'IDENTITY(' + LTRIM(c.IdentitySeed) + ',' + LTRIM(c.IdentityIncrement) + ') '
		ELSE ''
	END +
	case
		when c.Nullable=0
		then 'NOT NULL'
		else 'NULL'
	end +

-- [ModifiedDate] [datetime] NULL CONSTRAINT [DF_DescriptTable_ModifiedDate] DEFAULT (getdate()),
-- [SupportedDirections] [varchar] (10) COLLATE Cyrillic_General_CI_AS NOT NULL DEFAULT ((1))
	case
		when cd.colName is not null AND cd.[IsSystemNamed] = 1
		then ' DEFAULT ' + cd.[Text]
		when cd.colName is not null AND cd.[IsSystemNamed] = 0
		then ' CONSTRAINT ['+ cd.[defaultName] + '] DEFAULT ' + cd.[Text]
		else ''
	END +
	''
	 as sqltext,
	case
		when c.ID &lt; cols.cnt
		then 2
		else 0
	end as rowEnd
from
	#columns c
	outer apply (
		select count(1) cnt
		from sys.all_columns ac (nolock)
		where ac.object_id = c.objectid
	) cols
	LEFT JOIN #colDefaults cd
		ON cd.sName = c.sName
		AND cd.tName = c.tName
		AND cd.colName = c.colName

--4a. список индексов-ограничений (PK, UI)
SELECT
	Row_Number() Over (Partition by tbl.schema_id, tbl.name order by i.index_id) rn,
	Row_Number() Over (Partition by tbl.schema_id, tbl.name, case when is_primary_key=0 and is_unique_constraint=0 then 0 else 1 end order by i.index_id) rn_for_comma,
	i.index_id,
	SCHEMA_NAME(tbl.schema_id) AS sName,
	tbl.name AS tName,
	i.name AS iName,
	CAST(ISNULL(k.is_system_named, 0) AS bit) AS [IsSystemNamed],
	i.is_primary_key + 2*i.is_unique_constraint AS [IndexKeyType],
	i.is_unique AS [IsUnique],
	CAST(CASE i.index_id WHEN 1 THEN 1 ELSE 0 END AS bit) AS [IsClustered],
	CASE WHEN 'PS'=dsi.type THEN dsi.name ELSE N'' END AS [PartitionScheme],
	--CAST(case when i.type=3 then 1 else 0 end AS bit) AS [IsXmlIndex],
	--case UPPER(ISNULL(xi.secondary_type,'')) when 'P' then 1 when 'V' then 2 when 'R' then 3 else 0 end AS [SecondaryXmlIndexType],
	CASE WHEN 'FG'=dsi.type THEN dsi.name ELSE N'' END AS [FileGroup],
	i.ignore_dup_key AS [IgnoreDuplicateKeys],
	i.fill_factor AS [FillFactor],
	CAST(INDEXPROPERTY(i.object_id, i.name, N'IsPadIndex') AS bit) AS [PadIndex],
	~i.allow_row_locks AS [DisallowRowLocks],
	~i.allow_page_locks AS [DisallowPageLocks],
	s.no_recompute AS [NoAutomaticRecomputation],
	ISNULL(i.filter_definition, N'') AS [FilterDefinition]
INTO
	#index_name
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.indexes AS i ON (i.index_id &gt; 0 and i.is_hypothetical = 0) AND (i.object_id=tbl.object_id)
	LEFT OUTER JOIN sys.key_constraints AS k ON k.parent_object_id = i.object_id AND k.unique_index_id = i.index_id
	LEFT OUTER JOIN sys.data_spaces AS dsi ON dsi.data_space_id = i.data_space_id
	--LEFT OUTER JOIN sys.xml_indexes AS xi ON xi.object_id = i.object_id AND xi.index_id = i.index_id
	LEFT OUTER JOIN sys.stats AS s ON s.stats_id = i.index_id AND s.object_id = i.object_id
ORDER BY
	sName ASC, tName ASC, i.index_id ASC

/* шапка индекса */
insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	sName,
	tName,
	2001 +20*(rn-1) as rownum,
	'constr-index head' as rowtype,
	1,
	'CONSTRAINT [' +iName.iName +'] ' +
		case IndexKeyType
			when 1 then 'PRIMARY KEY '
			when 2 then 'UNIQUE '
			else '&lt;error&gt;'
		end +
		case IsClustered
			when 1 then 'CLUSTERED'
			else 'NONCLUSTERED'
		end +
		'(',
	0
from
	#index_name iName
where
	iName.IndexKeyType &gt; 0

/* подвал индекса-ограничения: в последней строке запятую можно оставить. Выполняется на mssql2005 */
union all
select
	sName,
	tName,
	2018 +20*(rn-1) as rownum,
	'constr-index footer' as rowtype,
	1,
	') '+
	case [FillFactor]
		when 0 then ''
		else 'WITH (FILLFACTOR=' +cast([FillFactor] as varchar) +') '
	end +
	'ON [' +[FileGroup] +']',
	case rn_for_comma
		when indexes.cnt then 0
		else 2
	end
from
	#index_name iName
	outer apply (
		select count(1) cnt
		from #index_name i
		where i.sName = iName.sName
			AND i.tName = iName.tName
			AND IndexKeyType &gt;0
	) indexes
where
	iName.IndexKeyType &gt; 0

--4b. столбцы индексов-ограничений
SELECT
	SCHEMA_NAME(tbl.schema_id) AS sName,
	tbl.name AS tName,
	i.name AS iName,
	--(case ic.key_ordinal when 0 then cast(1 as tinyint) else ic.key_ordinal end) AS [ID],
	ic.key_ordinal ID,
	clmns.name AS colName,
	ic.is_included_column AS [IsIncluded],
	Row_Number() OVER (
		Partition by tbl.[schema_id], tbl.name, i.name, ic.key_ordinal, ic.is_included_column
		Order by ic.index_column_id
		) Included_ID,
	ic.is_descending_key AS [Descending],
	CAST(COLUMNPROPERTY(ic.object_id, clmns.name, N'IsComputed') AS bit) AS [IsComputed]
INTO #index_columns
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.indexes AS i ON (i.index_id &gt; 0 and i.is_hypothetical = 0) AND (i.object_id=tbl.object_id)
	INNER JOIN sys.index_columns AS ic ON (ic.column_id &gt; 0 and (ic.key_ordinal &gt; 0 or ic.partition_ordinal = 0 or ic.is_included_column != 0)) AND (ic.index_id=CAST(i.index_id AS int) AND ic.object_id=i.object_id)
	INNER JOIN sys.columns AS clmns ON clmns.object_id = ic.object_id and clmns.column_id = ic.column_id
ORDER BY
	sName ASC, tName ASC, iName ASC,[ID] ASC


insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	iCols.sName,
	iCols.tName,
	2001 +20 *(iName.rn -1) +iCols.ID, --iCols.ID начинается с 1
	'constr-index column',
	2,
	'[' +iCols.colName +'] ' +
		case iCols.Descending
			when 0 then 'ASC'
			else 'DESC'
		end,
	case
		when iCols.ID = colsCount.cnt
		then 0
		else 2
	end
from
	#index_name iName
	INNER JOIN #index_columns iCols ON iCols.sName = iName.sName
									AND iCols.tName = iName.tName
									AND iCols.iName = iName.iName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.sName = iName.sName
			AND ic.tName = iName.tName
			AND ic.iName = iName.iName
	) colsCount
where
	iName.IndexKeyType &gt; 0


--5a. создание индексов

/* шапка индекса */
insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	sName,
	tName,
	7001 +1045*(rn-1) as rownum,
	'index head' as rowtype,
	0,
	'CREATE ' +
		case IsUnique
			when 1 then 'UNIQUE '
			else ''
		end +
		case IsClustered
			when 1 then 'CLUSTERED '
			else 'NONCLUSTERED '
		end +
		'INDEX [' +iName.iName +'] ON [' +iName.sName +'].[' +iName.tName +'] (',
	0
from
	#index_name iName
where
	iName.IndexKeyType = 0

/* подвал списка ключевых столбцов индекса */
union all
select
	sName,
	tName,
	7018 +1045*(rn-1) as rownum,
	'index key columns footer section' as rowtype,
	0,
	')',
	0
from
	#index_name iName
where
	iName.IndexKeyType = 0

/* шапка include-секции */
union all
select
	sName,
	tName,
	7019 +1045*(rn-1) as rownum,
	'index include-section' as rowtype,
	0,
	'INCLUDE (',
	0
from
	#index_name iName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.sName = iName.sName
			AND ic.tName = iName.tName
			AND ic.iName = iName.iName
			AND ic.isIncluded = 1
	) inclColumns
where
	iName.IndexKeyType = 0
	and inclColumns.cnt &gt; 0

/* ToDo: подвал include-секции */
union all
select
	sName,
	tName,
	8043 +1045*(rn-1) as rownum,
	'index include-footer section' as rowtype,
	0,
	')',
	0
from
	#index_name iName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.sName = iName.sName
			AND ic.tName = iName.tName
			AND ic.iName = iName.iName
			AND ic.isIncluded = 1
	) inclColumns
where
	iName.IndexKeyType = 0
	and inclColumns.cnt &gt; 0

/* where-секция (фильтр индекса) */
union all
select
	sName,
	tName,
	8044 +1045*(rn-1) as rownum,
	'index where-section (index filter)' as rowtype,
	0,
	'WHERE ' + iName.FilterDefinition,
	0
from
	#index_name iName
where
	iName.FilterDefinition &lt;&gt; ''

/* подвал индекса */
union all
select
	sName,
	tName,
	8045 +1045*(rn-1) as rownum,
	'index footer' as rowtype,
	0,
	case [FillFactor]
		when 0 then ''
		else 'WITH (FILLFACTOR=' +cast([FillFactor] as varchar) +') '
	end +
	'ON [' +[FileGroup] +']',
	1
from
	#index_name iName
where
	iName.IndexKeyType = 0


-- 5b. столбцы индекса
/* ключевые поля */
insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	iCols.sName,
	iCols.tName,
	7001 +1045 *(iName.rn -1) +iCols.ID, --iCols.ID начинается с 1
	'index key-column',
	1,
	'[' +iCols.colName +'] ' +
		case iCols.Descending
			when 0 then 'ASC'
			else 'DESC'
		end,
	case
		when iCols.ID = colsCount.cnt
		then 0
		else 2
	end
from
	#index_name iName
	INNER JOIN #index_columns iCols ON iCols.sName = iName.sName
									AND iCols.tName = iName.tName
									AND iCols.iName = iName.iName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.sName = iName.sName
			AND ic.tName = iName.tName
			AND ic.iName = iName.iName
			AND ic.IsIncluded = 0
	) colsCount
where
	iName.IndexKeyType = 0
	and iCols.IsIncluded = 0

union all
/* include-поля индекса */
select
	iCols.sName,
	iCols.tName,
	7020 +1045 *(iName.rn -1) +iCols.Included_ID, --iCols.IncludedID начинается с 1
	'index key-column',
	1,
	'[' +iCols.colName +']',
	case
		when iCols.Included_ID = colsCount.cnt
		then 0
		else 2
	end
from
	#index_name iName
	INNER JOIN #index_columns iCols ON iCols.sName = iName.sName
									AND iCols.tName = iName.tName
									AND iCols.iName = iName.iName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.sName = iName.sName
			AND ic.tName = iName.tName
			AND ic.iName = iName.iName
			AND ic.IsIncluded = 1
	) colsCount
where
	iName.IndexKeyType = 0
	and iCols.IsIncluded = 1



--6a. Внешние ключи
/*внешние ключи: название*/
SELECT
	Row_Number() Over (Partition by tbl.schema_id, tbl.name order by cstr.object_id) rn,
	SCHEMA_NAME(tbl.schema_id) AS sName,
	tbl.name AS tName,
	cstr.name AS fkName,
	CAST(cstr.is_system_named AS bit) AS [IsSystemNamed],
	cstr.delete_referential_action AS [DeleteAction],
	cstr.update_referential_action AS [UpdateAction],
	rtbl.name AS [ReferencedTable],
	schema_name(rtbl.schema_id) AS [ReferencedTableSchema],
	~cstr.is_not_trusted AS [IsChecked],
	~cstr.is_disabled AS [IsEnabled],
	cstr.is_not_for_replication AS [NotForReplication]
INTO #fk_name
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.foreign_keys AS cstr ON cstr.parent_object_id=tbl.object_id
	INNER JOIN sys.tables rtbl ON rtbl.object_id = cstr.referenced_object_id
ORDER BY
	sName ASC, tName ASC, fkName ASC

/* шапка внешнего ключа */
insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	sName,
	tName,
	269001 +2052 *(fkName.rn -1) as rownum,
	'fkey header',
	0,
	'ALTER TABLE [' +sName +'].[' +tName +'] WITH ' +
		case IsChecked
			when 1 then 'CHECK '
			else 'NOCHECK '
		end +
		char(13) + char(10) +
		'ADD CONSTRAINT [' +fkName +'] FOREIGN KEY ('
	as sqltext,
	0
from
	#fk_name fkName

union all
/* шапка перечисления столбцов таблицы, на которую ссылается внешний ключ */
select
	sName,
	tName,
	270026 +2052 *(fkName.rn -1),
	'fkey middle',
	0,
	') REFERENCES [' +ReferencedTableSchema +'].[' +ReferencedTable +'] (',
	0
from
	#fk_name fkName

union all
/* подвал внешнего ключа */
select
	sName,
	tName,
	271051 +2052 *(fkName.rn -1),
	'fkey footer',
	0,
	')',
	1
from
	#fk_name fkName


--6b. внешний ключ: столбцы
/* внешние ключи: определение */
SELECT
	SCHEMA_NAME(tbl.schema_id) AS sName,
	tbl.name AS tName,
	cstr.name AS fkName,
	fk.constraint_column_id AS ID,
	cfk.name AS colName,
	crk.name AS refColName
INTO #fk_cols
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.foreign_keys AS cstr ON cstr.parent_object_id=tbl.object_id
	INNER JOIN sys.foreign_key_columns AS fk ON fk.constraint_object_id=cstr.object_id
	INNER JOIN sys.columns AS cfk ON fk.parent_column_id = cfk.column_id and fk.parent_object_id = cfk.object_id
	INNER JOIN sys.columns AS crk ON fk.referenced_column_id = crk.column_id and fk.referenced_object_id = crk.object_id
ORDER BY
	sName ASC, tName ASC,fkName ASC, ID ASC

insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
/* столбцы таблицы, содержащей внешний ключ */
select
	fkName.sName,
	fkName.tName,
	269001 +2052 *(fkName.rn -1) +fkCols.ID, --ID начинается с 1
	'fkey columns',
	1 as indent,
	'[' +fkCols.colName +']',
	case fkCols.ID
		when fkColCount.cnt then 0
		else 2
	end
from
	#fk_name fkName
	INNER JOIN #fk_cols fkCols ON fkCols.sName = fkName.sName
								AND fkCols.tName = fkName.tName
								AND fkCols.fkName = fkName.fkName
	outer apply (
		select count(1) cnt
		from #fk_cols fc
		where fc.sName = fkName.sName
			AND fc.tName = fkName.tName
			AND fc.fkName = fkName.fkName
	) fkColCount

union all
/* столбцы таблицы, на которую ссылается внешний ключ */
select
	fkName.sName,
	fkName.tName,
	270026 +2052 *(fkName.rn -1) +fkCols.ID, --ID начинается с 1
	'fkey ref-columns',
	1 as indent,
	'[' +fkCols.refColName +']',
	case fkCols.ID
		when fkColCount.cnt then 0
		else 2
	end
from
	#fk_name fkName
	INNER JOIN #fk_cols fkCols ON fkCols.sName = fkName.sName
								AND fkCols.tName = fkName.tName
								AND fkCols.fkName = fkName.fkName
	outer apply (
		select count(1) cnt
		from #fk_cols fc
		where fc.sName = fkName.sName
			AND fc.tName = fkName.tName
			AND fc.fkName = fkName.fkName
	) fkColCount


--6c. выполнение проверки внешнего ключа
insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	sName,
	tName,
	271052 +2052 *(fkName.rn -1),
	'fkey check',
	0,
	'ALTER TABLE [' +sName +'].[' +tName +'] CHECK CONSTRAINT [' +fkName +']',
	1
from
	#fk_name fkName

--9. создание ограничений (проверок)
SELECT
	Row_Number() OVER (Partition by tbl.schema_id, tbl.name Order by cstr.name) rn,
	SCHEMA_NAME(tbl.schema_id) AS [sName],
	tbl.name AS [tName],
	cstr.name AS [constrName],
	cstr.is_not_for_replication AS [NotForReplication],
	~cstr.is_not_trusted AS [IsChecked],
	~cstr.is_disabled AS [IsEnabled],
	CAST(cstr.is_system_named AS bit) AS [IsSystemNamed],
	cstr.definition AS [Text]
INTO #table_chk
FROM
	sys.tables AS tbl
	INNER JOIN @objects ob ON ob.schemaName = SCHEMA_NAME(tbl.schema_id) AND ob.tableName = tbl.name
	INNER JOIN sys.check_constraints AS cstr ON cstr.parent_object_id=tbl.object_id
ORDER BY
	[sName] ASC,[tName] ASC,[constrName] ASC

insert @output (
	schemaName,
	tableName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	sName,
	tName,
	790001 +2*(rn-1),
	'check constraint',
	0,
	'ALTER TABLE [' +sName +'].[' +tName +'] WITH '+
		case IsChecked
			when 0 then 'NOCHECK '
			else 'CHECK '
		end +
		char(13) + char(10) +
		'ADD CONSTRAINT [' +constrName +'] CHECK ' +
		case NotForReplication
			when 1 then 'NOT FOR REPLICATION '
			else ''
		end +
		[Text],
	1
from
	#table_chk

union all
select
	sName,
	tName,
	790002 +2*(rn-1),
	'enable check constraint',
	0,
	'ALTER TABLE [' +sName +'].[' +tName +'] '+
		case IsEnabled
			when 1 then 'CHECK '
			else 'NOCHECK '
		end +
		'CONSTRAINT [' +constrName +']',
	1
from
	#table_chk
--select * from #ansi_params
--select * from #columns
--SELECT * FROM #colDefaults
--select * from #index_name
--select * from #index_columns
--select * from #fk_name
--select * from #fk_cols
--select * from #table_chk

declare @v varchar(max), @v_fk varchar(max)
select @v = '', @v_fk = ''
select
	@v = @v +
	space(o.indent) +
	o.sqltext +
	case endtype
		when 0 then ''
		when 1 then char(13) +char(10) +'GO' + char(13) +char(10) + '---------------------------------------------------'
		when 2 then ','
	end +
	char(13) +char(10)
from @output o
where o.rowType &lt;&gt; 'ANSI-params' -- исключаем из вывода на экран
order by schemaName, tableName, o.rownum

select [definition] = @v

--select *
--from @output
--order by schemaName, tableName, rownum</value>
    <comment>Получить скрипт создания таблицы</comment>
  </data>
  <data name="showTableTypeSource" xml:space="preserve">
    <value>set nocount on
declare @ObjectFullName sysname;
--set @ObjectFullName = 'dbo.UserTableTypeOne'
set @ObjectFullName = @ObjectName;

declare @ObjectFullNameWithBrackets nvarchar(2000);

/* исходящие строки */
declare @output table (
	objectFullName sysname not null,
	rownum bigint not null,
	rowtype varchar(50) not null,
	indent int default(0), --отступ при форматировании запроса
	sqltext varchar(max) null,
	endType tinyint default(0) --тип строки. 0-обычная, 1-после строки GO, 2-после строки запятая

	primary key (objectFullName, rownum)
)

if object_id('tempdb..#ansi_params') is not null
  drop table #ansi_params;

if object_id('tempdb..#columns') is not null
  drop table #columns;

IF OBJECT_ID('tempdb..#colDefaults') IS NOT NULL
  DROP TABLE #colDefaults;

if object_id('tempdb..#index_name') is not null
  drop table #index_name;

if object_id('tempdb..#index_columns') is not null
  drop table #index_columns;

if object_id('tempdb..#fk_name') is not null
  drop table #fk_name;

if object_id('tempdb..#fk_cols') is not null
  drop table #fk_cols;

if object_id('tempdb..#table_chk') is not null
  drop table #table_chk;


--1. определение параметров объекта
SELECT
	ISNULL(s1tt.name, N'') AS [Owner],
	CAST(case when tt.principal_id is null then 1 else 0 end AS bit) AS [IsSchemaOwned],
	tt.name AS [Name],
	tt.type_table_object_id AS [ID],
	SCHEMA_NAME(tt.schema_id) AS [Schema],
	obj.create_date AS [CreateDate],
	obj.modify_date AS [DateLastModified],
	tt.max_length AS [MaxLength],
	tt.is_nullable AS [Nullable],
	ISNULL(tt.collation_name, N'') AS [Collation],
	CAST(case when tt.is_user_defined = 1 then 1 else 0 end AS bit) AS [IsUserDefined],
	CAST(tt.is_memory_optimized AS bit) AS [IsMemoryOptimized]
into #ansi_params
FROM
	sys.table_types AS tt
	LEFT JOIN sys.database_principals AS s1tt ON s1tt.principal_id = ISNULL(tt.principal_id, (TYPEPROPERTY(QUOTENAME(SCHEMA_NAME(tt.schema_id)) + '.' + QUOTENAME(tt.name), 'OwnerId')))
	INNER JOIN sys.schemas AS stt ON stt.schema_id = tt.schema_id
	LEFT JOIN sys.objects AS obj ON obj.object_id = tt.type_table_object_id
WHERE
	SCHEMA_NAME(tt.schema_id) + '.' + tt.name = @ObjectFullName -- название со схемой, но может быть без скобок
;

select TOP(1) @ObjectFullNameWithBrackets = '[' + ap.[Schema] + '].['+ ap.[Name] + ']'
from #ansi_params ap;

insert @output (
	objectFullName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	@ObjectFullNameWithBrackets,
	0,
	'ANSI-params',
	'SET ANSI_NULLS ON' sqltext,
	1
from
	#ansi_params

insert @output (
	objectFullName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	@ObjectFullNameWithBrackets,
	1,
	'ANSI-params',
	'SET QUOTED_IDENTIFIER ON' sqltext,
	1
from
	#ansi_params

--2. нужен ли SET ANSI_PADDING?

--3a. создание названия таблицы
insert @output (
	objectFullName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	@ObjectFullNameWithBrackets,
	5,
	'tableTypeHeader',
	'CREATE TYPE [' +[Schema] +'].[' +[Name] +'] as TABLE (',
	0
from
	#ansi_params


insert @output (
	objectFullName,
	rownum,
	rowtype,
	sqltext,
	endType
)
select
	@ObjectFullNameWithBrackets,
	7000,
	'tableTypeFooter',
	')',
	1
from
	#ansi_params


--3b. создание столбцов таблицы
SELECT
	@ObjectFullNameWithBrackets [objectFullName],
	clmns.name AS [colName],
	clmns.column_id AS [ID],
	clmns.object_id as objectId,
	clmns.is_nullable AS [Nullable],
	clmns.is_computed AS [Computed],
	CAST(ISNULL(cik.index_column_id, 0) AS bit) AS [InPrimaryKey],
	clmns.is_ansi_padded AS [AnsiPaddingStatus],
	CAST(clmns.is_rowguidcol AS bit) AS [RowGuidCol],
	CAST(ISNULL(cc.is_persisted, 0) AS bit) AS [IsPersisted],
	ISNULL(clmns.collation_name, N'') AS [Collation],
	CAST(ISNULL((select TOP 1 1 from sys.foreign_key_columns AS colfk where colfk.parent_column_id = clmns.column_id and colfk.parent_object_id = clmns.object_id), 0) AS bit) AS [IsForeignKey],
	clmns.is_identity AS [Identity],
	CAST(ISNULL(ic.seed_value,0) AS bigint) AS [IdentitySeed],
	CAST(ISNULL(ic.increment_value,0) AS bigint) AS [IdentityIncrement],
	(case when clmns.default_object_id = 0 then N'' when d.parent_object_id &gt; 0 then N'' else d.name end) AS [Default],
	(case when clmns.default_object_id = 0 then N'' when d.parent_object_id &gt; 0 then N'' else schema_name(d.schema_id) end) AS [DefaultSchema],
	(case when clmns.rule_object_id = 0 then N'' else r.name end) AS [Rule],
	(case when clmns.rule_object_id = 0 then N'' else schema_name(r.schema_id) end) AS [RuleSchema],
	CAST(ISNULL(COLUMNPROPERTY(clmns.object_id, clmns.name, N'IsDeterministic'),0) AS bit) AS [IsDeterministic],
	CAST(ISNULL(COLUMNPROPERTY(clmns.object_id, clmns.name, N'IsPrecise'),0) AS bit) AS [IsPrecise],
	ISNULL(ic.is_not_for_replication, 0) AS [NotForReplication],
	CAST(COLUMNPROPERTY(clmns.object_id, clmns.name, N'IsFulltextIndexed') AS bit) AS [IsFullTextIndexed],
	CAST(COLUMNPROPERTY(clmns.object_id, clmns.name, N'StatisticalSemantics') AS int) AS [StatisticalSemantics],
	CAST(clmns.is_filestream AS bit) AS [IsFileStream],
	CAST(clmns.is_sparse AS bit) AS [IsSparse],
	CAST(clmns.is_column_set AS bit) AS [IsColumnSet],
	usrt.name AS [DataType],
	s1clmns.name AS [DataTypeSchema],
	ISNULL(baset.name, N'') AS [SystemType],
	CAST(CASE WHEN baset.name IN (N'nchar', N'nvarchar') AND clmns.max_length &lt;&gt; -1 THEN clmns.max_length/2 ELSE clmns.max_length END AS int) AS [Length],
	CAST(clmns.precision AS int) AS [NumericPrecision],
	CAST(clmns.scale AS int) AS [NumericScale],
	ISNULL(xscclmns.name, N'') AS [XmlSchemaNamespace],
	ISNULL(s2clmns.name, N'') AS [XmlSchemaNamespaceSchema],
	ISNULL( (case clmns.is_xml_document when 1 then 2 else 1 end), 0) AS [XmlDocumentConstraint],
	CASE WHEN usrt.is_table_type = 1 THEN N'structured' ELSE N'' END AS [UserType]
INTO #columns
FROM
	sys.table_types AS tt
	INNER JOIN sys.schemas AS stt ON stt.schema_id = tt.schema_id
	INNER JOIN sys.all_columns AS clmns ON clmns.object_id=tt.type_table_object_id
	LEFT JOIN sys.indexes AS ik ON ik.object_id = clmns.object_id and 1=ik.is_primary_key
	LEFT JOIN sys.index_columns AS cik ON cik.index_id = ik.index_id and cik.column_id = clmns.column_id and cik.object_id = clmns.object_id and 0 = cik.is_included_column
	LEFT JOIN sys.computed_columns AS cc ON cc.object_id = clmns.object_id and cc.column_id = clmns.column_id
	LEFT JOIN sys.identity_columns AS ic ON ic.object_id = clmns.object_id and ic.column_id = clmns.column_id
	LEFT JOIN sys.objects AS d ON d.object_id = clmns.default_object_id
	LEFT JOIN sys.objects AS r ON r.object_id = clmns.rule_object_id
	LEFT JOIN sys.types AS usrt ON usrt.user_type_id = clmns.user_type_id
	LEFT JOIN sys.schemas AS s1clmns ON s1clmns.schema_id = usrt.schema_id
	LEFT JOIN sys.types AS baset ON (baset.user_type_id = clmns.system_type_id and baset.user_type_id = baset.system_type_id) or ((baset.system_type_id = clmns.system_type_id) and (baset.user_type_id = clmns.user_type_id) and (baset.is_user_defined = 0) and (baset.is_assembly_type = 1)) 
	LEFT JOIN sys.xml_schema_collections AS xscclmns ON xscclmns.xml_collection_id = clmns.xml_collection_id
	LEFT JOIN sys.schemas AS s2clmns ON s2clmns.schema_id = xscclmns.schema_id
WHERE
	'[' + SCHEMA_NAME(tt.schema_id) + '].[' + tt.name + ']' = @ObjectFullNameWithBrackets



-- 3c. Default значения
SELECT
	@ObjectFullNameWithBrackets as [objectFullName],
	clmns.name as [colName],
	cstr.name AS [defaultName],
	CAST(cstr.is_system_named AS BIT) AS [IsSystemNamed],
	cstr.definition AS [Text]
INTO #colDefaults
FROM
	sys.table_types AS tt
	INNER JOIN sys.schemas AS stt ON stt.schema_id = tt.schema_id
	INNER JOIN sys.all_columns AS clmns ON clmns.object_id=tt.type_table_object_id
	INNER JOIN sys.default_constraints AS cstr ON cstr.object_id=clmns.default_object_id
WHERE
	'[' + SCHEMA_NAME(tt.schema_id) + '].[' + tt.name + ']' = @ObjectFullNameWithBrackets
ORDER BY
	[defaultName] ASC

insert @output (
	objectFullName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	c.objectFullName,
	10 +c.ID,--rowid,
	'columns',
	1,
	'[' +c.colName +'] [' +c.DataType +'] ' +
	case
		when lower(c.DataType)='char' OR lower(c.DataType)='nchar' OR lower(c.DataType)='binary'
		then '(' +cast(c.[Length] as varchar) +') '

		when lower(c.DataType)='varchar' OR lower(c.DataType)='nvarchar' OR lower(c.DataType)='varbinary'
		then '('+
			case c.[Length]
				when -1 then 'max'
				else cast(c.[Length] as varchar)
			end +
			') '

		when lower(c.DataType)='numeric' OR lower(c.DataType)='decimal'
		then '(' +cast(c.NumericPrecision as varchar) +',' +cast(c.NumericScale as varchar) +') '

		when lower(c.DataType)='float'
		then '(' +cast(c.NumericPrecision as varchar) +') '		

		else ''
	end +
	case
		when isnull(c.Collation, '')=''
		then ''
		else 'COLLATE ' +c.Collation +' '
	end +

	CASE
		WHEN c.[Identity] = 1
		THEN 'IDENTITY(' + LTRIM(c.IdentitySeed) + ',' + LTRIM(c.IdentityIncrement) + ') '
		ELSE ''
	END +
	case
		when c.Nullable=0
		then 'NOT NULL'
		else 'NULL'
	end +

	case
		when cd.colName is not null AND cd.[IsSystemNamed] = 1
		then ' DEFAULT ' + cd.[Text]
		when cd.colName is not null AND cd.[IsSystemNamed] = 0
		then ' CONSTRAINT ['+ cd.[defaultName] + '] DEFAULT ' + cd.[Text]
		else ''
	END +
	''
	 as sqltext,
	case
		when c.ID &lt; cols.cnt
		then 2
		else 0
	end as rowEnd
from
	#columns c
	outer apply (
		select count(1) cnt
		from sys.all_columns ac (nolock)
		where ac.object_id = c.objectId
	) cols
	LEFT JOIN #colDefaults cd
		ON cd.objectFullName = c.objectFullName
		AND cd.colName = c.colName

--4a. список индексов-ограничений (PK, UI)
SELECT
	@ObjectFullNameWithBrackets objectFullName,
	i.name AS [indexName],
	Row_Number() Over (Partition by tt.schema_id, tt.name order by i.index_id) rn,
	Row_Number() Over (Partition by tt.schema_id, tt.name, case when i.is_primary_key=0 and i.is_unique_constraint=0 then 0 else 1 end order by i.index_id) rn_for_comma,
	CAST(i.index_id AS int) AS [ID],
	CAST(OBJECTPROPERTY(i.object_id,N'IsMSShipped') AS bit) AS [IsSystemObject],
	ISNULL(s.no_recompute,0) AS [NoAutomaticRecomputation],
	i.fill_factor AS [FillFactor],
	CAST(CASE i.index_id WHEN 1 THEN 1 ELSE 0 END AS bit) AS [IsClustered],
	i.is_primary_key + 2*i.is_unique_constraint AS [IndexKeyType],
	i.is_unique AS [IsUnique],
	i.ignore_dup_key AS [IgnoreDuplicateKeys],
	~i.allow_row_locks AS [DisallowRowLocks],
	~i.allow_page_locks AS [DisallowPageLocks],
	CAST(ISNULL(INDEXPROPERTY(i.object_id, i.name, N'IsPadIndex'), 0) AS bit) AS [PadIndex],
	i.is_disabled AS [IsDisabled],
	CAST(ISNULL(k.is_system_named, 0) AS bit) AS [IsSystemNamed],
	CAST(INDEXPROPERTY(i.object_id,i.name,N'IsFulltextKey') AS bit) AS [IsFullTextKey],
	CAST(case when i.type=3 then 1 else 0 end AS bit) AS [IsXmlIndex],
	CAST(case when i.type=4 then 1 else 0 end AS bit) AS [IsSpatialIndex],
	i.has_filter AS [HasFilter],
	ISNULL(i.filter_definition, N'') AS [FilterDefinition],
	CASE WHEN 'PS'=dsi.type THEN dsi.name ELSE N'' END AS [PartitionScheme],
	CAST(CASE WHEN 'PS'=dsi.type THEN 1 ELSE 0 END AS bit) AS [IsPartitioned],
	CASE WHEN 'FD'=dstbl.type THEN dstbl.name ELSE N'' END AS [FileStreamFileGroup],
	CASE WHEN 'PS'=dstbl.type THEN dstbl.name ELSE N'' END AS [FileStreamPartitionScheme],
	CAST(CASE WHEN filetableobj.object_id IS NULL THEN 0 ELSE 1 END AS bit) AS [IsFileTableDefined],
	CAST(case when (i.type=7) then hi.bucket_count else 0 end AS int) AS [BucketCount]
INTO
	#index_name
FROM
	sys.table_types AS tt
INNER JOIN sys.schemas AS stt ON stt.schema_id = tt.schema_id
INNER JOIN sys.indexes AS i ON (i.index_id &gt; 0 and i.is_hypothetical = 0) AND (i.object_id=tt.type_table_object_id)
LEFT JOIN sys.stats AS s ON s.stats_id = i.index_id AND s.object_id = i.object_id
LEFT JOIN sys.key_constraints AS k ON k.parent_object_id = i.object_id AND k.unique_index_id = i.index_id
LEFT JOIN sys.data_spaces AS dsi ON dsi.data_space_id = i.data_space_id
LEFT JOIN sys.tables AS t ON t.object_id = i.object_id
LEFT JOIN sys.data_spaces AS dstbl ON dstbl.data_space_id = t.Filestream_data_space_id and (i.index_id &lt; 2 or (i.type = 7 and i.index_id &lt; 3))
LEFT JOIN sys.filetable_system_defined_objects AS filetableobj ON i.object_id = filetableobj.object_id
LEFT JOIN sys.hash_indexes AS hi ON i.object_id = hi.object_id AND i.index_id = hi.index_id
WHERE
	'[' + SCHEMA_NAME(tt.schema_id) + '].[' + tt.name + ']' = @ObjectFullNameWithBrackets


/* шапка индекса */
insert @output (
	objectFullName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	objectFullName,
	2001 +20*(rn-1) as rownum,
	'constr-index head' as rowtype,
	1,
	case IndexKeyType
		when 1 then 'PRIMARY KEY '
		when 2 then 'UNIQUE '
		else '&lt;error&gt;'
	end +
	case IsClustered
		when 1 then 'CLUSTERED'
		else 'NONCLUSTERED'
	end +
	'(',
	0
from
	#index_name iName
where
	iName.IndexKeyType &gt;0

/* подвал индекса-ограничения: в последней строке запятую можно оставить. Выполняется на mssql2005 */
union all
select
	objectFullName,
	2018 +20*(rn-1) as rownum,
	'constr-index footer' as rowtype,
	1,
	') '+
	case [FillFactor]
		when 0 then ''
		else 'WITH (FILLFACTOR=' +cast([FillFactor] as varchar) +') '
	end,
	case rn_for_comma
		when indexes.cnt then 0
		else 2
	end
from
	#index_name iName
	outer apply (
		select count(1) cnt
		from #index_name i
		where i.objectFullName = iName.objectFullName
			AND i.IndexKeyType &gt;0
	) indexes
where
	iName.IndexKeyType&gt;0




--4b. столбцы индексов-ограничений
SELECT
	@ObjectFullNameWithBrackets objectFullName,
	i.name indexName,
	clmns.name AS [colName],
	ic.key_ordinal ID,
	--(case ic.key_ordinal when 0 then ic.index_column_id else ic.key_ordinal end) AS [ID],
	ic.is_descending_key AS [Descending],
	ic.is_included_column AS [IsIncluded],
	Row_Number() OVER (
		Partition by tt.[schema_id], tt.name, i.name, ic.key_ordinal, ic.is_included_column
		Order by ic.index_column_id
		) Included_ID,
	CAST(COLUMNPROPERTY(ic.object_id, clmns.name, N'IsComputed') AS bit) AS [IsComputed]
INTO #index_columns
FROM
	sys.table_types AS tt
	INNER JOIN sys.schemas AS stt ON stt.schema_id = tt.schema_id
	INNER JOIN sys.indexes AS i ON (i.index_id &gt; 0 and i.is_hypothetical = 0) AND (i.object_id=tt.type_table_object_id)
	INNER JOIN sys.index_columns AS ic ON (ic.column_id &gt; 0 and (ic.key_ordinal &gt; 0 or ic.partition_ordinal = 0 or ic.is_included_column != 0)) AND (ic.index_id=CAST(i.index_id AS int) AND ic.object_id=i.object_id)
	INNER JOIN sys.columns AS clmns ON clmns.object_id = ic.object_id and clmns.column_id = ic.column_id
WHERE
	'[' + SCHEMA_NAME(tt.schema_id) + '].[' + tt.name + ']' = @ObjectFullNameWithBrackets
ORDER BY
	objectFullName ASC, indexName ASC, ic.key_ordinal ASC



insert @output (
	objectFullName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	iCols.objectFullName,
	2001 +20 *(iName.rn -1) +iCols.ID, --iCols.ID начинается с 1
	'constr-index column',
	2,
	'[' +iCols.colName +'] ' +
		case iCols.Descending
			when 0 then 'ASC'
			else 'DESC'
		end,
	case
		when iCols.ID = colsCount.cnt
		then 0
		else 2
	end
from
	#index_name iName
	INNER JOIN #index_columns iCols ON iCols.objectFullName = iName.objectFullName
									AND iCols.indexName = iName.indexName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.objectFullName = iName.objectFullName
			AND ic.indexName = iName.indexName
	) colsCount
where
	iName.IndexKeyType&gt;0


--5a. создание индексов

/* шапка индекса */
insert @output (
	objectFullName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	objectFullName,
	7001 +1042*(rn-1) as rownum,
	'index head' as rowtype,
	0,
	'CREATE ' +
		case IsUnique
			when 1 then 'UNIQUE '
			else ''
		end +
		case IsClustered
			when 1 then 'CLUSTERED '
			else 'NONCLUSTERED '
		end +
		'INDEX [' +iName.indexName +'] ON ' +iName.objectFullName +' (',
	0
from
	#index_name iName
where
	IndexKeyType =0

/* шапка include-секции */
union all
select
	objectFullName,
	7018 +1042*(rn-1) as rownum,
	'index include-section' as rowtype,
	0,
	') INCLUDE (',
	0
from
	#index_name iName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.objectFullName = iName.objectFullName
			AND ic.indexName = iName.indexName
			AND ic.isIncluded = 1
	) inclColumns
where
	IndexKeyType =0
	and inclColumns.cnt&gt;0

/* подвал индекса */
union all
select
	objectFullName,
	8042 +1042*(rn-1) as rownum,
	'index footer' as rowtype,
	0,
	') ' +
	case [FillFactor]
		when 0 then ''
		else 'WITH (FILLFACTOR=' +cast([FillFactor] as varchar) +') '
	end,
	1
from
	#index_name
where
	IndexKeyType=0


-- 5b. столбцы индекса
/* ключевые поля */
insert @output (
	objectFullName,
	rownum,
	rowtype,
	indent,
	sqltext,
	endType
)
select
	iCols.objectFullName,
	7001 +1042 *(iName.rn -1) +iCols.ID, --iCols.ID начинается с 1
	'index key-column',
	1,
	'[' +iCols.colName +'] ' +
		case iCols.Descending
			when 0 then 'ASC'
			else 'DESC'
		end,
	case
		when iCols.ID = colsCount.cnt
		then 0
		else 2
	end
from
	#index_name iName
	INNER JOIN #index_columns iCols ON iCols.objectFullName = iName.objectFullName
									AND iCols.indexName = iName.indexName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.objectFullName = iName.objectFullName
			AND ic.indexName = iName.indexName
			AND ic.IsIncluded = 0
	) colsCount
where
	iName.IndexKeyType=0
	and iCols.IsIncluded = 0

union all
/* include-поля индекса */
select
	iCols.objectFullName,
	7019 +1042 *(iName.rn -1) +iCols.Included_ID, --iCols.IncludedID начинается с 1
	'index key-column',
	1,
	'[' +iCols.colName +']',
	case
		when iCols.Included_ID = colsCount.cnt
		then 0
		else 2
	end
from
	#index_name iName
	INNER JOIN #index_columns iCols ON iCols.objectFullName = iName.objectFullName
									AND iCols.indexName = iName.indexName
	outer apply (
		select count(1) cnt
		from #index_columns ic
		where ic.objectFullName = iName.objectFullName
			AND ic.indexName = iName.indexName
			AND ic.IsIncluded = 1
	) colsCount
where
	iName.IndexKeyType=0
	and iCols.IsIncluded = 1


--select * from #ansi_params
--select * from #columns
--SELECT * FROM #colDefaults
--select * from #index_name
--select * from #index_columns

declare @v varchar(max)
select @v = ''
select
	@v = @v +
	space(o.indent) +
	o.sqltext +
	case endtype
		when 0 then ''
		when 1 then char(13) +char(10) +'GO' + char(13) +char(10) + '---------------------------------------------------'
		when 2 then ','
	end +
	char(13) +char(10)
from @output o
where o.rowType &lt;&gt; 'ANSI-params'
order by objectFullName, o.rownum



select [definition] =
	@v +char(13) +char(10);

select *
from @output
order by objectFullName, rownum</value>
  </data>
  <data name="tempTableId" xml:space="preserve">
    <value>select OBJECT_ID('tempdb..#weakObj')</value>
    <comment>Проверка на наличие рабочей таблицы</comment>
  </data>
</root>